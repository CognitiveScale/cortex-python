schema {
  query: Query
  mutation: Mutation
}

interface AttributeSpec {
  name: String!
  profileGroup: String
  source: ResourceRef
}

union ActionSpec = AgentActionSpec | ScriptActionSpec | SkillActionSpec

union LearningAlgorithmSpec = EpsilonGreedySpec | RNDSpec | SoftmaxSpec | SquareCBSpec

type AgentActionSpec {
  agent: ResourceRef!
}

"A Profile Attribute including metadata and attribute value"
type Attribute {
  group: String
  key: String!
  source: String!
  timestamp: Instant
  type: String!
  value: AttributeValue!
}

type AttributeIdentifier {
  name: String!
  sourceName: String!
}

type AttributeTag {
  attributes: [AttributeIdentifier!]!
  name: String!
}

type BucketAttributeSpec implements AttributeSpec {
  buckets: [BucketSpec!]!
  name: String!
  profileGroup: String
  source: ResourceRef
}

type BucketSpec {
  filter: String!
  name: String!
}

"Instance of an AI Campaign"
type Campaign {
  "The list of cohorts defined by this campaign"
  cohorts: [CohortSpec!]!
  description: String
  "The list of goals defined by this campaign"
  goals: [CampaignGoalSpec!]!
  lifecycleState: CampaignLifecycleState!
  "The list of missions belonging to this campaign"
  missions: [Mission!]!
  name: String!
  "The project that this campaign belongs to"
  project: Project!
  title: String
}

type CampaignGoalSpec {
  description: String
  kpis: [KPISpec!]!
  name: String!
}

type CohortGroupSpec {
  filter: String!
  name: String!
}

type CohortSpec {
  groups: [CohortGroupSpec!]!
  name: String!
  profileSchema: ResourceRef!
}

type CommitInfo {
  clusterId: String
  isBlindAppend: Boolean
  isolationLevel: String
  operation: String
  operationMetrics: JSON
  operationParams: JSON
  readVersion: Long
  timestamp: Timestamp!
  userId: String
  userMetadata: String
  version: Long!
}

type ConditionSpec {
  expression: String!
  name: String!
}

"Instance of a Connection"
type Connection {
  allowRead: Boolean!
  allowWrite: Boolean!
  connectionType: ConnectionType!
  contentType: ContentType
  description: String
  name: String!
  params: [PropertyValue!]!
  "The project that this connection belongs to"
  project: Project!
  title: String
}

type CustomAttributeSpec implements AttributeSpec {
  expression: String!
  name: String!
  profileGroup: String
  source: ResourceRef
  window: MeasureFrequency
}

"Instance of a Data Sink"
type DataSink {
  attributes: [String!]
  connection: ResourceRef
  description: String
  kind: SinkKind!
  name: String!
  "The project that this data sink belongs to"
  project: Project!
  title: String
}

"Instance of a Data Source"
type DataSource {
  attributes: [String!]
  connection: ResourceRef
  description: String
  kind: SourceKind!
  name: String!
  primaryKey: String
  "The project that this data source belongs to"
  project: Project!
  query: UserQuerySpec
  title: String
  userId: String
}

type DataSourceSelection {
  attributes: [String!]
  name: String!
  profileGroup: String
  profileKey: String!
  timestamp: TimestampSpec!
}

"Instance of a Data Stream Status"
type DataStreamStatus {
  batchId: Long!
  endOffset: Long!
  lastProcessedSource: String
  lastUpdated: Timestamp
  project: String!
  resourceName: String!
  resourceType: ResourceType!
  status: StreamStatus!
}

type EffectSpec {
  probability: Float!
  script: String!
}

type EpsilonGreedySpec {
  epsilon: Float!
  policy: PolicyEvaluation!
}

type ExperimentStatus {
  averageReward: Float!
  currentIteration: Int!
  evaluation: String
  experimentId: String!
  exploration: String
  totalIterations: Int!
}

type ExplorationSpec {
  epsilon: Float
  lambda: Int
  type: ExplorationType!
}

"Instance of a Favorite Query"
type FavoriteQuery {
  id: String
  lastUpdated: Timestamp
  profileSchemaId: String
  project: String
  query: String!
}

type Feature {
  dataType: String
  description: String
  featureName: String!
  featureType: String
  maxValue: Float
  meanValue: Float
  minValue: Float
  notes: String
  observations: String
  pctDom: Float
  pctNull: Float
  profileGroup: String!
  projectName: String!
  sourceName: String!
  stdDev: Float
  tableName: String!
  timestamp: Timestamp
  uniqueCount: Long
}

type FixedTimestamp {
  format: String
  value: String!
}

type GoalSpec {
  condition: String!
  name: String!
}

"Represents the count of group requested in a grouping query"
type GroupCount {
  count: Long!
  key: String!
}

type InterventionSpec {
  action: ActionSpec
  condition: String
  cost: Float!
  effects: [EffectSpec!]!
  name: String!
  timeout: Int
  timeout_unit: TimeoutUnit
}

type InterventionStatus {
  attemptCount: Long!
  interventionId: Int!
  interventionName: String
  successCount: Long!
}

"Metadata about a job running withing the platform"
type JobInfo {
  endTime: Instant
  errorMessage: String
  isActive: Boolean!
  isCancelled: Boolean!
  isComplete: Boolean!
  isError: Boolean!
  jobId: String!
  jobType: String!
  project: String!
  resourceName: String!
  resourceType: String!
  startTime: Instant
  status: JobStatus!
}

type JoinSourceSelection {
  attributes: [String!]
  join: JoinSpec!
  name: String!
  profileGroup: String
  timestamp: TimestampSpec!
}

type JoinSpec {
  joinSourceColumn: String!
  joinType: String
  primarySourceColumn: String!
}

type KPIMeasureSpec {
  displayFormat: String
  expression: String!
  isPercentage: Boolean!
  name: String!
  profileSchema: ResourceRef!
}

type KPISpec {
  cohortName: String!
  description: String
  endingOn: Date
  frequency: MeasureFrequency!
  measure: KPIMeasureSpec!
  name: String!
  startingOn: Date
  startingValue: Float
  targetValue: Float
  valueDirection: ValueDirection!
}

"Represents the current value of a KPI"
type KPIValue {
  availableDataPoints: Int!
  finalFrequency: MeasureFrequency!
  measureName: String!
  measures: [MeasureValue!]!
  name: String!
  requestedFrequency: MeasureFrequency!
  startingValue: Float
  targetValue: Float
}

"A value for a measure within a specific time window"
type MeasureValue {
  message: String
  value: Float
  windowEnd: Timestamp
  windowStart: Timestamp
}

"Instance of an AI Mission"
type Mission {
  "The campaign that this Mission belongs to"
  campaign: Campaign!
  campaignName: String!
  conditions: [ConditionSpec!]!
  description: String
  goal: GoalSpec!
  "The list of interventions configured for this Mission"
  interventions: [InterventionSpec!]!
  lifecycleState: MissionLifecycleState!
  name: String!
  project: String!
  simulatedAttributes: [SimulatedAttribute!]
  simulation: SimulationSpec
  simulationV2: SimulationSpecV2
  subject: SubjectSpec!
  title: String
}

type Mutation {
  "Build profiles according to the specified ProfileSchema"
  buildProfile(
    "The name of the ProfileSchema to build"
    profileSchema: String!,
    "The name of the Cortex project"
    project: String!
  ): JobInfo!
  "Cancel a running job.  If the job is not running on this server, returns false, but notifies other cluster members to cancel the job."
  cancelJob(jobId: String!, project: String!): Boolean!
  "Cancel a running simulation for an AI Mission"
  cancelSimulation(project: String!, simulationId: String!): SimulationCanceled!
  "Create a new profile bucket attribute"
  createBucketAttribute(input: CreateBucketAttributeInput!): ProfileSchema!
  "Create a Campaign"
  createCampaign(input: CreateCampaignInput!): Campaign!
  "Create a Connection"
  createConnection(input: ConnectionInput!): Connection!
  "Create a new custom profile attribute"
  createCustomAttribute(input: CreateCustomAttributeInput!): ProfileSchema!
  "Create a Data Sink"
  createDataSink(input: DataSinkInput!): DataSink!
  "Create a Data Source"
  createDataSource(input: DataSourceInput!): DataSource!
  "Create a Favorite Query"
  createFavoriteQuery(input: FavoriteQueryInput!): FavoriteQuery!
  "Create new a Mission"
  createMission(input: CreateMissionInput!): Mission!
  "Create an expert review of plans generated in a simulation"
  createPlanReview(input: CreatePlanReviewInput!): ID!
  "Create a Profile Link"
  createProfileLink(input: CreateProfileLinkInput!): ProfileLink!
  "Create a ProfileSchema"
  createProfileSchema(input: ProfileSchemaInput!): ProfileSchema!
  "Create a Project"
  createProject(input: CreateProjectInput!): Project!
  deleteAllProfiles(
    "The name of the ProfileSchema to build"
    profileSchema: String!,
    "The name of the Cortex project"
    project: String!
  ): JobInfo!
  "Delete an existing profile bucket attribute"
  deleteBucketAttribute(input: DeleteBucketAttributeInput!): ProfileSchema!
  "Delete a Campaign and all of its resources"
  deleteCampaign(input: CampaignDeleteInput!): Boolean!
  "Delete a Connection"
  deleteConnection(input: DeleteConnectionInput!): Boolean!
  "Delete an existing custom profile attribute"
  deleteCustomAttribute(input: DeleteCustomAttributeInput!): ProfileSchema!
  "Delete a Data Source and all of its resources"
  deleteDataSource(input: DeleteDataSourceInput!): Boolean!
  "Delete a Favorite Query"
  deleteFavoriteQuery(id: String!): Boolean!
  "Delete a Mission and all of its resources"
  deleteMission(input: DeleteMissionInput!): Boolean!
  "Delete an expert review of plans generated in a simulation"
  deletePlanReview(input: DeletePlanReviewInput!): Boolean!
  "Delete Profile Links"
  deleteProfileLinks(input: DeleteProfileLinkInput!): Boolean!
  "Delete a ProfileSchema and all of its resources"
  deleteProfileSchema(input: DeleteProfileSchemaInput!): Boolean!
  deleteProfiles(
    "A ProfileScript used to filter profiles based on their attributes"
    filter: String!,
    "The name of the ProfileSchema to build"
    profileSchema: String!,
    "The name of the Cortex project"
    project: String!
  ): JobInfo!
  "Delete a Project and all of its resources"
  deleteProject(name: String!): Boolean!
  "Delete simulation data, cancelling the simulation if currently running"
  deleteSimulation(project: String!, simulationId: String!): Boolean!
  exportProfiles(
    "A ProfileScript used to filter profiles based on their attributes"
    filter: String,
    "Limit exported records to this number"
    limit: Int,
    "The name of the ProfileSchema to export"
    profileSchema: String!,
    "The name of the Cortex project"
    project: String!,
    "The name of the Data Sink to export to"
    sink: String!,
    "Desired write mode"
    writeMode: WriteMode!
  ): JobInfo!
  "Run ingestion for the specified Data Source"
  ingestSource(
    "The name of the Cortex project"
    project: String!,
    "The name of the Data Source to ingest"
    source: String!
  ): JobInfo!
  "Refine an AI Mission using expert reviews"
  refineUsingReviews(input: RefineUsingReviewsInput!): JobInfo!
  "Remove a Goal from a Campaign"
  removeCampaignGoal(input: RemoveCampaignGoalInput!): Campaign!
  "Remove a Cohort from a Campaign"
  removeCohort(input: RemoveCohortInput!): Campaign!
  "Remove a Condition in a Mission"
  removeCondition(input: RemoveConditionInput!): Mission!
  "Remove an Intervention in a Mission"
  removeIntervention(input: RemoveInterventionInput!): Mission!
  "Simulate an AI Mission"
  runSimulation(input: RunSimulationInput!): RunSimulationPayload! @deprecated(reason : "Will be removed in future release, replace with runSimulationV2")
  "Simulate an AI Mission"
  runSimulationV2(input: RunSimulationV2Input!): RunSimulationPayload!
  "Add or update a Goal for a Campaign"
  saveCampaignGoal(input: SaveCampaignGoalInput!): Campaign!
  "Add or update a Cohort for a Campaign"
  saveCohort(input: SaveCohortInput!): Campaign!
  "Add or update a Condition for a Mission"
  saveCondition(input: SaveConditionInput!): Mission!
  "Add or update an Intervention for a Mission"
  saveIntervention(input: SaveInterventionInput!): Mission!
  "Update an existing profile bucket attribute"
  updateBucketAttribute(input: UpdateBucketAttributeInput!): ProfileSchema!
  "Update a Campaign"
  updateCampaign(input: UpdateCampaignInput!): Campaign!
  "Update the lifecycle state of an existing Campaign"
  updateCampaignLifecycleState(input: UpdateCampaignLifecycleStateInput!): Campaign!
  "Update a Connection"
  updateConnection(input: ConnectionInput!): Connection!
  "Update an existing custom profile attribute"
  updateCustomAttribute(input: UpdateCustomAttributeInput!): ProfileSchema!
  "Update a Data Sink"
  updateDataSink(input: DataSinkInput!): DataSink!
  "Update a Data Source"
  updateDataSource(input: DataSourceInput!): DataSource!
  "Update a Favorite Query"
  updateFavoriteQuery(input: FavoriteQueryInput!): FavoriteQuery!
  "Update the Features associated with a Data Source"
  updateFeaturesForSource(
    "The list of features to save"
    features: [FeatureInput!]!,
    "The name of the Cortex project"
    project: String!,
    "The name of the Resource"
    source: String!
  ): [Feature!]!
  "Update an existing Mission"
  updateMission(input: UpdateMissionInput!): Mission!
  "Update the lifecycle state of an existing Mission"
  updateMissionLifecycleState(input: UpdateMissionLifecycleStateInput!): Mission!
  "Update an expert review of plans generated in a simulation"
  updatePlanReview(input: UpdatePlanReviewInput!): ID!
  "Update a ProfileSchema"
  updateProfileSchema(input: ProfileSchemaInput!): ProfileSchema!
  updateProfiles(
    "The name of the ProfileSchema to build"
    profileSchema: String!,
    "The profiles and attributes to be upserted"
    profiles: [String!]!,
    "The name of the Cortex project"
    project: String!
  ): JobInfo!
  "Update a Project"
  updateProject(input: UpdateProjectInput!): Project!
}

type PlanForReview {
  cost: Float!
  interventions: [String!]!
  planID: ID!
  rank: Int!
  subjectCount: Long!
  subjects: [ID!]!
}

type PlanReview {
  cost: Float!
  finalRank: Int!
  groupFilter: String!
  initialRank: Int!
  planID: ID!
  project: String!
  reviewId: ID!
  reviewerId: ID!
  simulationId: String!
  timestamp: Instant!
}

type PlanSubjectAttribute {
  key: String!
  type: String!
  value: AttributeValue!
}

type PlanSubjectDetails {
  attributes: [PlanSubjectAttribute!]!
  profileId: String!
}

type PlanningSummary {
  end: Instant
  experimentId: String!
  goalCount: Int!
  interventionStatus: [InterventionStatus!]!
  plansReviewed: Long!
  plansReviewedPercent: Float!
  progressCount: Int!
  start: Instant
  subjectPoolSize: Int!
}

type PlansForReview {
  planTotal: Long!
  plans: [PlanForReview!]!
  subjectTotal: Long!
}

"A Cortex Profile including it's set of attributes"
type Profile {
  attributes: [Attribute!]!
  profileID: ID!
  profileSchema: String!
}

type ProfileCommit {
  commitInfo: CommitInfo!
  profileSchema: String!
  project: String!
}

"Instance of a Profile Link"
type ProfileLink {
  linkedProfileAttribute: String!
  linkedProfileSchemaId: String!
  profileAttribute: String!
  profileSchemaId: String!
  project: String!
}

type ProfileNames {
  categories: [String!]!
  plural: String!
  singular: String!
  title: String!
}

"Instance of a Profile Schema"
type ProfileSchema {
  attributeTags: [AttributeTag!]
  bucketAttributes: [BucketAttributeSpec!]!
  customAttributes: [CustomAttributeSpec!]!
  description: String
  joins: [JoinSourceSelection!]
  name: String!
  names: ProfileNames!
  primarySource: DataSourceSelection!
  "The project that this profile schema belongs to"
  project: Project!
  title: String
  userId: String
}

"Instance of a Project"
type Project {
  "The campaigns that belong to this project"
  campaigns: [Campaign!]!
  "The connections that belong to this project"
  connections: [Connection!]!
  createdAt: Instant
  "The data sources that belong to this project"
  dataSources: [DataSource!]!
  description: String
  name: String!
  "The profile links that belong to this project"
  profileLinks: [ProfileLink!]!
  "The profile schemas that belong to this project"
  profileSchemas: [ProfileSchema!]!
  title: String
  version: Long
}

type PropertyValue {
  name: String!
  value: String!
}

type Query {
  "Get Campaign by name"
  campaignByName(name: String!, project: String!): Campaign!
  "List Campaigns in a Project"
  campaigns(filter: String, limit: String, project: String!, skip: String, sort: String): [Campaign!]!
  "Count profiles in a Cohort based on specified groupings"
  cohortGroupCount(
    "The name of the AI Campaign"
    campaign: String!,
    "The name of the Cohort in the campaign to query"
    cohortName: String!,
    "The list of attributes to group profiles by"
    groupBy: [String!]!,
    "Limit the number of profiles counted"
    limit: Int,
    "The name of the Cortex project"
    project: String!
  ): [GroupCount!]!
  "Get Connection by name"
  connectionByName(name: String!, project: String!): Connection!
  "List Connections"
  connections(project: String!): [Connection!]!
  "Get Data Source by name"
  dataSourceByName(name: String!, project: String!): DataSource!
  "List Data Sources"
  dataSources(project: String!): [DataSource!]!
  "Retrieve a Data Stream Status"
  dataStreamStatus(
    "The name of the Cortex project"
    project: String!,
    "The resource name"
    resourceName: String!,
    "The type of resource"
    resourceType: ResourceType!
  ): DataStreamStatus!
  "List Favorite Queries"
  favoriteQueries(filter: ListFavoriteQueriesInput!): [FavoriteQuery!]!
  "Preview the Features associated with a Data Source"
  featuresForSource(
    "The name of the Cortex project"
    project: String!,
    "The name of the Data Source"
    source: String!
  ): [Feature!]!
  "Lookup a job by ID"
  jobById(jobId: String!, project: String!): JobInfo!
  "List asynchronous jobs for a project"
  jobs(project: String!): [JobInfo!]!
  "List asynchronous jobs for a resource by type and name"
  jobsForResource(project: String!, resourceName: String!, resourceType: String!): [JobInfo!]!
  "Query the KPI values for a specific goal"
  kpiValues(campaign: String!, goal: String!, limit: Int, project: String!): [KPIValue!]!
  "Get the ID of the last simulation run for this Mission"
  lastSimulationId(campaign: String!, completedOnly: Boolean!, mission: String!, project: String!): String
  "List running simulations in a mission"
  listRunningSimulations(campaign: String!, mission: String!, project: String!): [SimulationInfo!]!
  "List simulations in a mission"
  listSimulations(campaign: String!, limit: Int, mission: String!, offset: Int, project: String!): [SimulationInfoV2!]!
  "Get Mission by name"
  missionByName(campaign: String!, name: String!, project: String!): Mission!
  "List Missions in a Campaign"
  missions(campaign: String!, filter: String, limit: String, project: String!, skip: String, sort: String): [Mission!]!
  "Retrieve plans generated by a simulation that match a subject filter"
  plansForReview(
    "Only return plans that match this filter"
    filter: String,
    "Limit the number of plans returned"
    limit: Int,
    "Project name"
    project: String!,
    "ID of the simulation"
    simulationId: String!
  ): PlansForReview!
  "Preview a Connection"
  previewConnection(
    "The name of the Connection to preview"
    connection: String!,
    "The name of the Cortex project"
    project: String!
  ): SourcePreview!
  "Preview the data for a Data Source"
  previewSource(
    "The name of the Cortex project"
    project: String!,
    "The name of the Data Source to preview"
    source: String!
  ): SourcePreview!
  "Retrieves a Profile by ID"
  profileById(
    "The unique ID of the Profile"
    id: ID!,
    "The name of the Profile schema resource (profile type)"
    profileSchema: String!,
    "The name of the Cortex project"
    project: String!
  ): Profile
  "Count profiles"
  profileCount(
    "A ProfileScript used to filter profiles based on their attributes"
    filter: String,
    "The name of the Profile schema resource (profile type)"
    profileSchema: String!,
    "The name of the Cortex project"
    project: String!
  ): Long!
  "Get the list of profile features (attributes)"
  profileFeatures(
    "Include campaign feedback attributes"
    campaign: String,
    "The name of the Profile schema resource (profile type)"
    profileSchema: String!,
    "The name of the Cortex project"
    project: String!
  ): [Feature!]!
  "Count profiles based on specified groupings"
  profileGroupCount(
    "A ProfileScript used to filter profiles based on their attributes"
    filter: String,
    "The list of attributes to group profiles by"
    groupBy: [String!]!,
    "Limit the number of profiles counted"
    limit: Int,
    "The name of the Profile schema resource (profile type)"
    profileSchema: String!,
    "The name of the Cortex project"
    project: String!
  ): [GroupCount!]!
  "Get the change history for profile data"
  profileHistory(
    "The maximum number of entries to return"
    limit: Int,
    "The name of the Profile Schema resource (profile type)"
    profileSchema: String!,
    "The name of the Cortex project"
    project: String!
  ): [ProfileCommit!]!
  "List Profile Links"
  profileLinks(
    "The name of the linked profile attribute"
    linkedProfileAttribute: String,
    "The name of the linked profile schema"
    linkedProfileSchema: String,
    "The name of the profile attribute"
    profileAttribute: String,
    "The name of the profile schema"
    profileSchema: String!,
    "The name of the Cortex project"
    project: String!
  ): [ProfileLink!]!
  "Get Profile Schema by name"
  profileSchemaByName(name: String!, project: String!): ProfileSchema!
  "List profile schemas"
  profileSchemas(project: String!): [ProfileSchema!]!
  "Get Profile Source by name"
  profileSourceByName(name: String!, project: String!): DataSource! @deprecated(reason : "Will be removed, replace with dataSourceByName(project, name)")
  "List Profile Sources"
  profileSources(project: String!): [DataSource!]! @deprecated(reason : "Will be removed, replace with dataSources(project)")
  "Query profiles"
  profiles(
    "Restrict the returned attributes to these keys"
    attributes: [String!],
    "A ProfileScript used to filter profiles based on their attributes"
    filter: String,
    "The maximum number of profiles to return"
    limit: Int,
    "The name of the Profile schema resource (profile type)"
    profileSchema: String!,
    "The name of the Cortex project"
    project: String!,
    "Restrict the returned attributes to those with any of these tags"
    tags: [String!]
  ): [Profile!]!
  "List profiles for the supplied mission plan"
  profilesForPlan(
    "Only return plans that match this filter"
    filter: String,
    "Limit the number of plans returned"
    limit: Int,
    "ID of the mission plan"
    planId: String!,
    "The name of the Profile schema resource (profile type)"
    profileSchema: String!,
    "Project name"
    project: String!,
    "ID of the simulation"
    simulationId: String!
  ): [Profile!]!
  "Get Project by name"
  projectByName(name: String!): Project!
  "List Project Count"
  projectCount(filter: String): Int!
  "List Projects"
  projects(filter: String, limit: String, skip: String, sort: String): [Project!]!
  "Preview the data schema for a Data Source"
  schemaForSource(
    "The name of the Cortex project"
    project: String!,
    "The name of the Data Source to preview"
    source: String!
  ): [SourceField!]!
  "Get Attributes Used in the Simulation"
  simulationAttributes(
    "Project name"
    project: String!,
    "ID of the simulation"
    simulationId: String!
  ): [String!]!
  "Count profiles in a simulation based on specified groupings"
  simulationGroupCount(
    "A filter for the query"
    filter: String,
    "The list of attributes to group profiles by"
    groupBy: [String!]!,
    "Project name"
    project: String!,
    "ID of the simulation"
    simulationId: String!
  ): [GroupCount!]!
  "List reviews for a simulation matching the supplied filter"
  simulationReviews(
    "Addition review filter on fields like reviewId, reviewerId, cost, finalRank, etc."
    filter: String,
    "Group filter used to create the reviews"
    groupFilter: String,
    "Limit the number of plans returned"
    limit: Int,
    "Project name"
    project: String!,
    "ID of the simulation"
    simulationId: String!
  ): [PlanReview!]!
  "Gets the status of simulation"
  simulationStatus(simulationId: String!): SimulationSummary!
  "Get the change history for profile source data"
  sourceHistory(
    "The maximum number of entries to return"
    limit: Int,
    "The name of the Cortex project"
    project: String!,
    "The name of the Data Source"
    source: String!
  ): [SourceCommit!]!
  "List subject details for a mission plan"
  subjectDetailsForPlan(
    "Only return plans that match this filter"
    filter: String,
    "Remove Non Profile Fields"
    keepNonProfileFields: Boolean!,
    "Limit the number of plans returned"
    limit: Int,
    "ID of the mission plan"
    planId: String!,
    "ID of the profile"
    profileId: String,
    "Project name"
    project: String!,
    "ID of the simulation"
    simulationId: String!
  ): [PlanSubjectDetails!]!
  "Test a Data Source query syntax and connectivity"
  testDataSource(input: DataSourceInput!): [ValidationResponse!]!
}

type RNDSpec {
  alpha: Float
  epsilon: Float
  invLambda: Float
  policy: PolicyEvaluation!
  predictors: Int!
}

"A record from a Data Source"
type Record {
  attributes: [Attribute!]!
  recordID: ID
}

type ResourceRef {
  name: String!
}

type RunSimulationPayload {
  campaign: String!
  jobInfo: JobInfo!
  mission: String!
  project: String!
  simulationId: String!
}

type ScriptActionSpec {
  language: ScriptLanguage!
  script: String!
}

type SimulatedAttribute {
  dataType: AttributeDataType!
  initialValue: String!
  name: String!
}

type SimulationCanceled {
  cancelTime: Instant!
  simulationId: String!
}

type SimulationInfo {
  end: Instant
  experiments: [ExperimentStatus!]!
  planning: PlanningSummary
  simulationId: String!
  simulationType: String
  start: Instant
  status: SimulationStatus!
  statusMessage: String
}

type SimulationInfoV2 {
  end: Instant
  experiments: [ExperimentStatus!]!
  planning: PlanningSummary
  simulationId: String!
  simulationType: String
  start: Instant
  status: SimulationStatus!
  statusMessage: String
}

type SimulationSpec {
  attributes: [String!]
  exploration: [ExplorationSpec!]!
  iterations: Int!
  limit: Int
  order: [String!]
  policy: [PolicyEvaluation!]!
  seed: Int
}

type SimulationSpecV2 {
  asV1: SimulationSpec!
  seed: Int
  subjectAttributes: [String!]
  subjectLimit: Int
  subjectOrder: [String!]
  trainingIterations: Int!
  trainingSpecs: [LearningAlgorithmSpec!]!
  verbose: Boolean!
}

type SimulationSummary {
  campaign: String
  dataPointsProcessed: Int
  end: Instant
  iterationsPerExperiment: Int
  mission: String
  planning: PlanningSummary
  profilesProcessed: Int
  project: String
  simulationId: String!
  simulationType: String
  start: Instant
  status: SimulationStatus!
  statusMessage: String
  subjectPoolSize: Int
  timestamp: Instant!
  totalExperiments: Int
  totalInterventionsProcessed: Long
  totalPlansGenerated: Int
  training: TrainingSummary
}

type SkillActionSpec {
  skill: ResourceRef!
}

type SoftmaxSpec {
  lambda: Int!
  policy: PolicyEvaluation!
}

type SourceCommit {
  commitInfo: CommitInfo!
  project: String!
  sourceName: String!
}

type SourceField {
  dataType: String!
  featureType: String!
  name: String!
}

"A preview of a ProfileSource including feature information and sample data"
type SourcePreview {
  "Statistical sample of the data used in analysis"
  dataSample: [Record!]!
  "List of discovered features in the source"
  features: [Feature!]!
}

type SquareCBSpec {
  elimination: Boolean!
  gammaExponent: Int
  gammaScale: Int!
  maxCost: Float
  mellowness: Float
  minCost: Float
  policy: PolicyEvaluation!
}

type SubjectSpec {
  cohort: String!
}

type Subscription {
  "Subscription for simulation status"
  simulationProgress(simulationId: String!): SimulationSummary
}

type TimestampSpec {
  auto: Boolean
  field: String
  fixed: FixedTimestamp
  format: String
}

type TrainingSummary {
  experiments: [ExperimentStatus!]!
}

type UserQuerySpec {
  dialect: UserQueryDialectSpec!
  queryString: String!
  variables: [UserQueryVariableSpec!]!
}

type UserQueryVariableSpec {
  dataType: String!
  default: String
  name: String!
}

type ValidationPath {
  index: Int
  name: String
  type: String!
}

type ValidationResponse {
  message: String!
  path: [ValidationPath!]!
}

enum AttributeDataType {
  BOOLEAN
  DOUBLE
  INTEGER
  LONG
  STRING
}

enum CampaignLifecycleState {
  DEPLOYED
  IN_PROGRESS
}

enum ConnectionType {
  file
  gcs
  gcsFileStream
  hive
  jdbc
  jdbc_cdata
  jdbc_generic
  mongo
  s3
  s3FileStream
}

enum ContentType {
  csv
  json
  parquet
}

enum ExplorationType {
  EPSILON_GREEDY
  RND
  SOFTMAX
  SQUARE_CB
}

enum JobStatus {
  ACTIVE
  CANCELLED
  COMPLETE
  ERROR
  QUEUED
  SUBMITTED
}

enum MeasureFrequency {
  DAILY
  MONTHLY
  WEEKLY
  YEARLY
}

enum MissionLifecycleState {
  ARCHIVED
  DEPLOYED
  EDITING
  READY_FOR_DEPLOYMENT
  REVIEWING
  SIMULATING
}

enum PolicyEvaluation {
  DM
  DR
  IPS
  MTR
}

enum ResourceType {
  DATA_SOURCE
  PROFILE_SCHEMA
}

enum ScriptLanguage {
  Javascript
  Python
  RobotFramework
}

enum SimulationStatus {
  CANCELLED
  COMPLETED
  ERROR
  INITIALIZING
  PLANNING
  REFINING
  RUNNING
  TRAINING
  UNKNOWN
}

enum SinkKind {
  BATCH
  STREAMING
}

enum SourceKind {
  batch
  streaming
}

enum StreamStatus {
  AWAITING
  PROCESSING
}

enum TimeoutUnit {
  DAY
  HOUR
  MINUTE
  MONTH
  SECOND
  WEEK
  YEAR
}

enum UserQueryDialectSpec {
  NATIVE
  SPARK_SQL
}

enum ValueDirection {
  DOWN
  NONE
  UP
}

enum WriteMode {
  APPEND
  ERROR
  OVERWRITE
}

"A profile attribute value"
scalar AttributeValue

"An RFC-3339 compliant Full Date Scalar"
scalar Date

"An instant in time"
scalar Instant

"A JSON scalar"
scalar JSON

"A 64-bit signed integer"
scalar Long

"An timestamp"
scalar Timestamp

input AgentActionSpecInput {
  agent: ResourceRefInput!
}

input AttributeIdentifierInput {
  name: String!
  sourceName: String!
}

input AttributeTagInput {
  attributes: [AttributeIdentifierInput!]!
  name: String!
}

input BucketAttributeSpecInput {
  buckets: [BucketSpecInput!]!
  name: String!
  profileGroup: String
  source: ResourceRefInput
}

input BucketSpecInput {
  filter: String!
  name: String!
}

input CampaignDeleteInput {
  name: String!
  project: String!
}

input CampaignGoalSpecInput {
  description: String
  kpis: [KPISpecInput!]!
  name: String!
}

input CohortGroupSpecInput {
  filter: String!
  name: String!
}

input CohortSpecInput {
  groups: [CohortGroupSpecInput!]!
  name: String!
  profileSchema: ResourceRefInput!
}

input ConditionSpecInput {
  expression: String!
  name: String!
}

"Instance of a Connection"
input ConnectionInput {
  allowRead: Boolean!
  allowWrite: Boolean!
  connectionType: ConnectionType!
  contentType: ContentType
  description: String
  name: String!
  params: [PropertyValueInput!]!
  project: String!
  title: String
}

input CreateBucketAttributeInput {
  attribute: BucketAttributeSpecInput!
  profileSchema: String!
  project: String!
}

"Input used to create an AI Campaign"
input CreateCampaignInput {
  description: String
  name: String!
  project: String!
  title: String
}

input CreateCustomAttributeInput {
  attribute: CustomAttributeSpecInput!
  profileSchema: String!
  project: String!
}

"Input used to create an AI Mission"
input CreateMissionInput {
  campaign: String!
  conditions: [ConditionSpecInput!]
  description: String
  goal: GoalSpecInput!
  name: String!
  project: String!
  simulatedAttributes: [SimulatedAttributeInput!]
  simulation: SimulationSpecInput
  subject: SubjectSpecInput!
  title: String
}

"Create a review of plans previously retrieved by plansForReview"
input CreatePlanReviewInput {
  "The filter used to retrieve this set of plans for review"
  groupFilter: String!
  "The name of the project containing the simulation that generated this set of plans"
  project: String!
  "List of reviewed plans"
  reviewedPlans: [ReviewedPlanInput!]!
  "The ID of the simulation that generated this set of plans"
  simulationId: String!
}

input CreateProfileLinkInput {
  linkedProfileAttribute: String!
  linkedProfileSchema: String!
  profileAttribute: String!
  profileSchema: String!
  project: String!
}

"Create a new Project"
input CreateProjectInput {
  description: String
  name: String!
  title: String
}

input CustomAttributeSpecInput {
  expression: String!
  name: String!
  profileGroup: String
  source: ResourceRefInput
  window: MeasureFrequency
}

"Instance of a Data Sink"
input DataSinkInput {
  attributes: [String!]
  connection: ResourceRefInput
  description: String
  kind: SinkKind!
  name: String!
  project: String!
  title: String
}

"Instance of a Data Source"
input DataSourceInput {
  attributes: [String!]
  connection: ResourceRefInput
  description: String
  kind: SourceKind!
  name: String!
  primaryKey: String
  project: String!
  query: UserQuerySpecInput
  title: String
  userId: String
}

input DataSourceSelectionInput {
  attributes: [String!]
  name: String!
  profileGroup: String
  profileKey: String!
  timestamp: TimestampSpecInput!
}

input DeleteBucketAttributeInput {
  attributeName: String!
  profileSchema: String!
  project: String!
}

input DeleteConnectionInput {
  name: String!
  project: String!
}

input DeleteCustomAttributeInput {
  attributeName: String!
  profileSchema: String!
  project: String!
}

input DeleteDataSourceInput {
  name: String!
  project: String!
}

input DeleteMissionInput {
  campaign: String!
  name: String!
  project: String!
}

"Delete a previously created review"
input DeletePlanReviewInput {
  "The name of the project containing the simulation that generated this set of plans"
  project: String!
  "The ID of the review to delete"
  reviewId: ID!
  "The ID of the simulation that generated this set of plans"
  simulationId: String!
}

input DeleteProfileLinkInput {
  linkedProfileAttribute: String
  linkedProfileSchema: String
  profileAttribute: String
  profileSchema: String!
  project: String!
}

input DeleteProfileSchemaInput {
  name: String!
  project: String!
}

input EffectSpecInput {
  probability: Float!
  script: String!
}

input EpsilonGreedySpecInput {
  epsilon: Float!
  policy: PolicyEvaluation!
}

input ExplorationSpecInput {
  epsilon: Float
  lambda: Int
  type: ExplorationType!
}

"Instance of a Favorite Query"
input FavoriteQueryInput {
  id: String
  lastUpdated: Timestamp
  profileSchemaId: String
  project: String
  query: String!
}

input FeatureInput {
  dataType: String
  description: String
  featureName: String!
  featureType: String
  maxValue: Float
  meanValue: Float
  minValue: Float
  notes: String
  observations: String
  pctDom: Float
  pctNull: Float
  profileGroup: String!
  projectName: String!
  sourceName: String!
  stdDev: Float
  tableName: String!
  timestamp: Timestamp
  uniqueCount: Long
}

input FixedTimestampInput {
  format: String
  value: String!
}

input GoalSpecInput {
  condition: String!
  name: String!
}

"An Intervention to add or update inside a Mission"
input InterventionInput {
  agentAction: AgentActionSpecInput
  condition: String
  cost: Float
  effects: [EffectSpecInput!]
  name: String!
  scriptAction: ScriptActionSpecInput
  skillAction: SkillActionSpecInput
  timeout: Int
  timeout_unit: TimeoutUnit
}

input JoinSourceSelectionInput {
  attributes: [String!]
  join: JoinSpecInput!
  name: String!
  profileGroup: String
  timestamp: TimestampSpecInput!
}

input JoinSpecInput {
  joinSourceColumn: String!
  joinType: String
  primarySourceColumn: String!
}

input KPIMeasureSpecInput {
  displayFormat: String
  expression: String!
  isPercentage: Boolean!
  name: String!
  profileSchema: ResourceRefInput!
}

input KPISpecInput {
  cohortName: String!
  description: String
  endingOn: Date
  frequency: MeasureFrequency!
  measure: KPIMeasureSpecInput!
  name: String!
  startingOn: Date
  startingValue: Float
  targetValue: Float
  valueDirection: ValueDirection!
}

"Input used to list favorite queries"
input ListFavoriteQueriesInput {
  profileSchemaId: String
  project: String
}

input ProfileNamesInput {
  categories: [String!]!
  plural: String!
  singular: String!
  title: String!
}

"Instance of a Profile Schema"
input ProfileSchemaInput {
  attributeTags: [AttributeTagInput!]
  description: String
  joins: [JoinSourceSelectionInput!]
  name: String!
  names: ProfileNamesInput!
  primarySource: DataSourceSelectionInput!
  project: String!
  title: String
  userId: String
}

input PropertyValueInput {
  name: String!
  value: String!
}

input RNDSpecInput {
  alpha: Float
  epsilon: Float
  invLambda: Float
  policy: PolicyEvaluation!
  predictors: Int!
}

input RefineUsingReviewsInput {
  project: String!
  reviews: [ID!]!
  simulationId: String!
  warmStartSpec: WarmStartSpecInput
}

input RemoveCampaignGoalInput {
  campaign: String!
  goalName: String!
  project: String!
}

input RemoveCohortInput {
  campaign: String!
  cohortName: String!
  project: String!
}

input RemoveConditionInput {
  campaign: String!
  conditionName: String!
  mission: String!
  project: String!
}

input RemoveInterventionInput {
  campaign: String!
  interventionName: String!
  mission: String!
  project: String!
}

input ResourceRefInput {
  name: String!
}

input ReviewedPlanInput {
  cost: Float!
  finalRank: Int!
  ignore: Boolean
  initialRank: Int!
  planID: ID!
}

input RunSimulationInput {
  campaign: String!
  mission: String!
  project: String!
  simulationSpec: SimulationSpecInput
}

input RunSimulationV2Input {
  campaign: String!
  epsilonGreedy: EpsilonGreedySpecInput
  mission: String!
  project: String!
  rnd: RNDSpecInput
  seed: Int
  softmax: SoftmaxSpecInput
  squareCB: SquareCBSpecInput
  subjectAttributes: [String!]
  subjectLimit: Int
  subjectOrder: [String!]
  trainingIterations: Int
  verbose: Boolean
}

input SaveCampaignGoalInput {
  campaign: String!
  goal: CampaignGoalSpecInput!
  project: String!
}

input SaveCohortInput {
  campaign: String!
  cohort: CohortSpecInput!
  project: String!
}

input SaveConditionInput {
  campaign: String!
  condition: ConditionSpecInput!
  mission: String!
  project: String!
}

input SaveInterventionInput {
  campaign: String!
  intervention: InterventionInput!
  mission: String!
  project: String!
}

input ScriptActionSpecInput {
  language: ScriptLanguage!
  script: String!
}

input SimulatedAttributeInput {
  dataType: AttributeDataType!
  initialValue: String!
  name: String!
}

input SimulationSpecInput {
  attributes: [String!]
  exploration: [ExplorationSpecInput!]!
  iterations: Int!
  limit: Int
  order: [String!]
  policy: [PolicyEvaluation!]!
  seed: Int
}

input SkillActionSpecInput {
  skill: ResourceRefInput!
}

input SoftmaxSpecInput {
  lambda: Int!
  policy: PolicyEvaluation!
}

input SquareCBSpecInput {
  elimination: Boolean!
  gammaExponent: Int
  gammaScale: Int!
  maxCost: Float
  mellowness: Float
  minCost: Float
  policy: PolicyEvaluation!
}

input SubjectSpecInput {
  cohort: String!
}

input TimestampSpecInput {
  auto: Boolean
  field: String
  fixed: FixedTimestampInput
  format: String
}

input UpdateBucketAttributeInput {
  attribute: BucketAttributeSpecInput!
  profileSchema: String!
  project: String!
}

"Input used to update an AI Campaign"
input UpdateCampaignInput {
  description: String
  name: String!
  project: String!
  title: String
}

"Input used to update an AI Campaign's lifecycle state"
input UpdateCampaignLifecycleStateInput {
  campaign: String!
  newState: CampaignLifecycleState!
  project: String!
}

input UpdateCustomAttributeInput {
  attribute: CustomAttributeSpecInput!
  profileSchema: String!
  project: String!
}

"Input used to update an AI Mission"
input UpdateMissionInput {
  campaign: String!
  conditions: [ConditionSpecInput!]
  description: String
  goal: GoalSpecInput
  name: String!
  project: String!
  simulatedAttributes: [SimulatedAttributeInput!]
  simulation: SimulationSpecInput
  subject: SubjectSpecInput
  title: String
}

"Input used to update an AI Mission's lifecycle state"
input UpdateMissionLifecycleStateInput {
  campaign: String!
  mission: String!
  newState: MissionLifecycleState!
  project: String!
}

"Update a previously created review"
input UpdatePlanReviewInput {
  "The filter used to retrieve this set of plans for review"
  groupFilter: String!
  "The name of the project containing the simulation that generated this set of plans"
  project: String!
  "The ID of the review to update"
  reviewId: ID!
  "List of reviewed plans"
  reviewedPlans: [ReviewedPlanInput!]!
  "The ID of the simulation that generated this set of plans"
  simulationId: String!
}

"Update an existing Project"
input UpdateProjectInput {
  description: String
  name: String!
  title: String
}

input UserQuerySpecInput {
  dialect: UserQueryDialectSpec!
  queryString: String!
  variables: [UserQueryVariableSpecInput!]!
}

input UserQueryVariableSpecInput {
  dataType: String!
  default: String
  name: String!
}

input WarmStartSpecInput {
  choicesLambda: Int
  corruptProbWarmStart: Float
  corruptTypeWarmStart: Int
  epsilon: Float!
  fullRetrain: Boolean!
  interaction: Int!
  interactionUpdate: Boolean!
  lambdaScheme: Int
  learningRate: Float
  loss0: Int
  loss1: Int
  policy: PolicyEvaluation!
  seed: Int
  validationSplit: Float!
  warmStart: Int!
  warmStartUpdate: Boolean!
}